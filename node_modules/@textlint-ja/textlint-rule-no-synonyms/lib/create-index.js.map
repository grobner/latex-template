{"version":3,"sources":["../src/create-index.ts"],"names":["ItemGroup","constructor","items","getItem","midashi","find","item","usedItems","usedItemSet","allowAlphabet","allowNumber","allows","Array","from","values","filter","hyoukiYure","ryakusyou","includes","assertInstallationSudachiSynonymsDictionary","require","error","Error","_cache","Map","firstVocabularyNumber","createIndex","allowLexeme","has","Promise","resolve","get","keyItemGroupMap","SudachiSynonymsItemGroup","SynonymsDictionary","forEach","group","groupByVocabularyNumber","reduce","res","vocabularyNumber","concat","itemGroups","Object","length","map","itemGroup","oldItemGroup","set","_ret"],"mappings":"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","sourcesContent":["import { fetchDictionary, SudachiSynonyms } from \"sudachi-synonyms-dictionary\";\nimport { isNumberString } from \"./is-number\";\n\nexport type Midashi = string;\n\n/**\n * Dictionary Design\n *\n * // Index\n * <Midashi>: ItemGroup[]\n * // Check\n * SudachiSynonyms: boolean\n * ItemGroup: boolean\n * // Collection\n * usedItemGroup.forEach\n */\nexport class ItemGroup {\n    constructor(public items: SudachiSynonyms[]) {}\n\n    getItem(midashi: string): SudachiSynonyms | null {\n        return this.items.find((item) => item.midashi === midashi) ?? null;\n    }\n\n    usedItems(\n        usedItemSet: Set<SudachiSynonyms>,\n        { allowAlphabet, allowNumber, allows }: { allowAlphabet: boolean; allowNumber: boolean; allows: string[] }\n    ): SudachiSynonyms[] {\n        // sort by used\n        return Array.from(usedItemSet.values()).filter((item) => {\n            if (\n                allowAlphabet &&\n                (item.hyoukiYure === \"アルファベット表記\" || item.ryakusyou === \"略語・略称/アルファベット\")\n            ) {\n                // アルファベット表記\n                // blog <-> ブログ\n                // 略語・略称/アルファベット\n                // OS <-> オペレーションシステム\n                return false;\n            }\n            // 数値の違いは無視する\n            if (allowNumber && isNumberString(item.midashi)) {\n                return false;\n            }\n            if (allows.includes(item.midashi)) {\n                return false;\n            }\n            return this.items.includes(item);\n        });\n    }\n}\n\n/**\n * インストールのチェック\n */\nconst assertInstallationSudachiSynonymsDictionary = () => {\n    try {\n        require(\"sudachi-synonyms-dictionary\");\n    } catch (error) {\n        throw new Error(`sudachi-synonyms-dictionaryがインストールされていません。\nルールとは別にsudachi-synonyms-dictionaryをインストールしてください。\n      \n$ npm install sudachi-synonyms-dictionary\n\n\n`);\n    }\n};\nexport type IndexType = {\n    keyItemGroupMap: Map<Midashi, ItemGroup[]>;\n    SudachiSynonymsItemGroup: Map<SudachiSynonyms, ItemGroup>;\n};\nconst _cache = new Map<boolean, IndexType>();\nconst firstVocabularyNumber = 1;\nexport const createIndex = async ({ allowLexeme }: { allowLexeme: boolean }): Promise<IndexType> => {\n    if (_cache.has(allowLexeme)) {\n        return Promise.resolve(_cache.get(allowLexeme)!);\n    }\n    assertInstallationSudachiSynonymsDictionary();\n    const keyItemGroupMap: Map<Midashi, ItemGroup[]> = new Map();\n    const SudachiSynonymsItemGroup: Map<SudachiSynonyms, ItemGroup> = new Map();\n    const SynonymsDictionary = await fetchDictionary();\n    SynonymsDictionary.forEach((group) => {\n        const groupByVocabularyNumber = group.items.reduce((res, item) => {\n            const vocabularyNumber = allowLexeme ? item.vocabularyNumber! : firstVocabularyNumber;\n            res[vocabularyNumber] = (res[vocabularyNumber] || []).concat(item);\n            return res;\n        }, {} as { [index: string]: SudachiSynonyms[] });\n        const itemGroups = Object.values(groupByVocabularyNumber)\n            .filter((items) => {\n                return items.length > 1;\n            })\n            .map((items) => {\n                return new ItemGroup(items);\n            });\n        // register key with itemGroup\n        itemGroups.forEach((itemGroup) => {\n            itemGroup.items.forEach((item) => {\n                const oldItemGroup = keyItemGroupMap.get(item.midashi) || [];\n                keyItemGroupMap.set(item.midashi, oldItemGroup.concat(itemGroup));\n                SudachiSynonymsItemGroup.set(item, itemGroup);\n            });\n        });\n    });\n    const _ret = {\n        keyItemGroupMap,\n        SudachiSynonymsItemGroup\n    };\n    _cache.set(allowLexeme, _ret);\n    return Promise.resolve(_ret);\n};\n"],"file":"create-index.js"}